# Test for association between Na+ consumption and life expectancy, from 1990 to 2010
**Last edited: May 16, 2016**

**Kellie Ottoboni**

```{r knitr_options, include=FALSE}
library(knitr)
library(xtable)
opts_chunk$set(fig.width=12, fig.height=4, fig.path='RmdFigs/',
               warning=FALSE, message=FALSE)
```

```{r load_data}
set.seed(38)
library(dplyr)
library(Hmisc)
library(randomForest)
library(sandwich)
library(lmtest)
library(plm)
library(stargazer)
```

## Data cleaning

We need to clean up the data. This includes removing unwanted variables (we keep per capita GDP, alcohol consumption, and per capita cigarette consumption only) and imputing the missing values of the predictors. In particular:

* We merge two data sources. One contains the economic variables, life expectancy, alcohol, and sodium consumption. The other contains the annual number of cigarettes smoked per capita.

* We impute the missing 2010 sex-specific alcohol consumption for Taiwan using a linear regression of male and female life expectancy, male and female salt consumption, per capita GDP, and per capita annual cigarette consumption on sex-specific alcohol consumption. Then we impute population average alcohol consumption by taking a weighted average of male and female alcohol consumption, using the proportion of the population that is male/female as the weights.

* We impute the missing 1990 overall alcohol consumption for Taiwan in the same way as before, regressing predictors on overall alcohol consumption. Then we use the proportion of alcohol consumption in 2010 attributable to males and females to estimate the male and female sex-specific alcohol consumption in 1990, respectively.

```{r impute}
salt <- read.table("../Data/omnibus_data.csv", sep = "\t", header = TRUE)
salt <- salt %>% mutate("etoh_M" = etohM, "etoh_F" = etohF)
smoke <- read.table("../Data/smoking_t14.csv", sep = ",", header = TRUE)
smoke <- dplyr::select(smoke, country_name_p, annual_pc_smoking_1990, annual_pc_smoking_2010)


salt <- mutate(salt, popF_prop = popF/(popF + popM), popM_prop = popM/(popF + popM))
salt$popF_prop[is.na(salt$popF)] <- 0.5; salt$popM_prop[is.na(salt$popM)] <- 0.5
salt$etohboth <- ifelse(is.na(salt$etohboth), salt$popM_prop*salt$etoh_M + salt$popF_prop*salt$etoh_F, salt$etohboth)

salt <- arrange(salt, country, year)
salt_filt <- dplyr::select(salt, country, country_name_p, e0_M, e0_F, year, Na_M, Na_F, etohboth, etoh_M, etoh_F, pc_gdp, popM_prop, popF_prop)

salt2010 <- filter(salt_filt, year == 2010)
salt2010 <- merge(smoke, salt2010)
salt2010 <- dplyr::select(salt2010, -annual_pc_smoking_1990, -country_name_p) %>% mutate(smoking = annual_pc_smoking_2010) %>% dplyr::select(-annual_pc_smoking_2010)
etoh_M_mod <- lm(etoh_M~ e0_M + e0_F + Na_M + Na_F + pc_gdp + smoking, data = salt2010)
etoh_F_mod <- lm(etoh_F~ e0_M + e0_F + Na_M + Na_F + pc_gdp + smoking, data = salt2010)
twn <- which(is.na(salt2010$etoh_M))
salt2010[twn, "etoh_M"] <- predict(etoh_M_mod, salt2010[twn,]); salt2010[twn, "etoh_F"] <- predict(etoh_F_mod, salt2010[twn,])
salt2010[twn, "etohboth"] <- (salt2010$popM_prop*salt2010$etoh_M + salt2010$popF_prop*salt2010$etoh_F)[twn]

salt1990 <- filter(salt_filt, year == 1990)
salt1990 <- merge(smoke, salt1990)
salt1990 <- dplyr::select(salt1990, -annual_pc_smoking_2010, -country_name_p)  %>% mutate(smoking = annual_pc_smoking_1990) %>% dplyr::select(-annual_pc_smoking_1990)
etohboth_mod <- lm(etohboth ~ e0_M + e0_F + Na_M + Na_F + pc_gdp + smoking, data = salt1990)
twn <- which(is.na(salt1990$etohboth))
salt1990[twn, "etohboth"] <- predict(etohboth_mod, salt1990[twn,])
salt1990$etoh_M     <- salt1990$etohboth * (salt2010$etoh_M)/(salt2010$popM_prop*salt2010$etoh_M+salt2010$popF_prop*salt2010$etoh_F)
salt1990$etoh_F     <- salt1990$etohboth * (salt2010$etoh_F)/(salt2010$popM_prop*salt2010$etoh_M+salt2010$popF_prop*salt2010$etoh_F)
```

```{r malefemale_diff}
countries <- salt2010$country
salt_diff <- salt2010[,-1]-salt1990[,-1]
salt_diff <- cbind(countries, salt_diff)
salt_diff <- filter(salt_diff, !is.na(e0_M))

male_diff <- dplyr::select(salt_diff, e0_M, etoh_M, smoking, pc_gdp, Na_M)
colnames(male_diff) <- gsub("_M", "", colnames(male_diff))
female_diff <- dplyr::select(salt_diff,  e0_F, etoh_F, smoking, pc_gdp, Na_F)
colnames(female_diff) <- gsub("_F", "", colnames(female_diff))
```
```{r malefemale_absolute}
salt_absolute <- rbind(salt1990, salt2010)
salt_absolute$year <- c(rep("1990", nrow(salt1990)), rep("2010", nrow(salt2010)))
salt_absolute <- salt_absolute %>% filter(!is.na(e0_M) & !is.na(e0_F))
male_absolute <- dplyr::select(salt_absolute, e0_M, country, year, etoh_M, smoking, pc_gdp, Na_M)
colnames(male_absolute) <- gsub("_M", "", colnames(male_absolute))
female_absolute <- dplyr::select(salt_absolute, e0_F, country, year, etoh_F, smoking, pc_gdp, Na_F)
colnames(female_absolute) <- gsub("_F", "", colnames(female_absolute))
```

## Variable importance

In his seminal paper on random forests, Leo Breiman introduced a variable importance measure based on permutations. The idea is that if a variable is important in a regression, then perturbing it will worsen the predictive performance. On the other hand, if we perturb a variable and the predictions remain relatively good, then the variable is not important to the model. We perturb the variables by permuting them, breaking the association between the feature and all other variables and the outcome.

Though the idea of permutation variable importance came from random forests, it is sufficiently general that it can apply to any predictive model. We can use several metrics for this: we report the "absolute importance", the original prediction error minus average permuted prediction error, and the "normalized importance", the absolute importance divided by the original prediction error. Large values indicate more importance.
Consistently for different cuts of the data and different methods, sodium intake appears to be the least important predictor. However, sodium is more important than smoking when we look at the cross-sectional datasets using OLS with interactions.


```{r variable_importance, echo=FALSE}
compute_rmse <- function(prediction, truth){
  sqrt(mean((prediction-truth)^2, na.rm=TRUE))
}

permutation_variable_importance <- function(Xmat, Y, model, nperm = 1000){
  # Carry out permutation variable importance
  # Input:
  # Xmat  = a matrix or dataframe of features
  # Y     = a vector of outcomes, one for each row in Xmat
  # model = a model object to be passed into predict
  # nperm = number of permuted datasets to simulate. Default 1000

  baseline_rmse <- compute_rmse(predict(model, Xmat), Y)
  p <- ncol(Xmat)
  Xmat_perm <- Xmat
  RMSEmat <- matrix(NA, nrow = nperm, ncol = p)
  colnames(RMSEmat) <- colnames(Xmat)
  for(i in seq_len(p)){
    RMSEmat[,i] <- replicate(nperm, {
      Xmat_perm[,i] <- sample(Xmat_perm[,i])
      compute_rmse(predict(model, Xmat_perm), Y)
    })
  }
  avg_permuted_rmse <- apply(RMSEmat, 2, mean)
  avg_variable_importance <- baseline_rmse - avg_permuted_rmse
  normalized_variable_importance <- avg_variable_importance/baseline_rmse
  return(list(
    "importance" = -1*avg_variable_importance,
    "normalized" = -1*normalized_variable_importance
    ))
}

compute_variable_importance <- function(dataset){
  # Takes as input a dataframe with both X and Y (e0)
  # Outputs variable importance for each feature, according to a bunch of different models
  Xmat = dataset %>% dplyr::select(-e0)
  Y = dataset %>% dplyr::select(e0)
  model_list <- list(
    "rf"               = randomForest(e0~., data = dataset),
    "ols"              = lm(e0~., data = dataset),
    "ols_interactions" = lm(e0~(.)^2, data = dataset)
  )
  lapply(model_list, function(mod) permutation_variable_importance(Xmat, Y, mod, nperm = 100))
}

permutation_importance_table <- function(perm_imp, title){
  abs <- do.call(rbind, lapply(perm_imp, function(x) x[[1]]))
  abs <- round(abs, 3)
  norm <- do.call(rbind, lapply(perm_imp, function(x) x[[2]]))
  norm <- round(norm, 3)
  p <- ncol(abs)
  tab <- rbind(c("Absolute importance", rep("", p-1), "Normalized importance", rep("", p-1)), rep(colnames(abs, 2)), cbind(abs, norm))
  rownames(tab)[1:2] <- c("", "Variable")
  print(xtable(tab, align = "r|llll|llll",
               caption = title),
        include.rownames = TRUE,
        include.colnames = FALSE,
        type="html")
}
```


```{r do_variable_importance, echo=FALSE, results = "asis", cache=TRUE}
compute_variable_importance(male_diff) %>% permutation_importance_table(title = "Male, Differenced")
compute_variable_importance(female_diff) %>% permutation_importance_table(title = "Female, Differenced")
compute_variable_importance(male_absolute %>% select(-year, -country)) %>% permutation_importance_table(title = "Male, Absolute")
compute_variable_importance(female_absolute %>% select(-year, -country)) %>% permutation_importance_table(title = "Female, Absolute")

```

## Conditional Variable Importance

We may want to do the conditional permutation tests in this paper: http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-307
They first use cart to partition the observations according to the other covariates, then permute within those groups instead of permuting everything.
This is supposed to account for dependence between features.


## Linear models

```{r linear_models, echo=FALSE}

compute_linear_models_differenced <- function(dataset){
  # Takes in a dataset of differenced measures
  mod0 <- lm(e0~Na, data=dataset)
  OLS_plain <- coeftest(mod0)
  robust_plain <- coeftest(mod0, vcov = vcovHC(mod0, type = "HC1"))
  
  mod1 <- lm(e0~Na+etoh, data=dataset)
  OLS_etoh <- coeftest(mod1)
  robust_etoh <- coeftest(mod1, vcov = vcovHC(mod1, type = "HC1"))

  mod2 <- lm(e0~Na+etoh+smoking, data=dataset)
  OLS_etoh_smoke <- coeftest(mod2)
  robust_etoh_smoke <- coeftest(mod2, vcov = vcovHC(mod2, type = "HC1"))
  
  mod <- lm(e0~., data=dataset)
  OLS <- coeftest(mod)
  robust <- coeftest(mod, vcov = vcovHC(mod, type = "HC1"))
  return(list(
    "OLS plain" = OLS_plain,
    "robust plain" = robust_plain,
    "OLS etoh" = OLS_etoh,
    "robust etoh" = robust_etoh,
    "OLS etoh smoke" = OLS_etoh_smoke,
    "robust etoh smoke" = robust_etoh_smoke,
    "OLS" = OLS,
    "robust" = robust
  ))
}

compute_fixed_effects <- function(dataset){
  # Takes in a dataset with a column of years and country names
  predictors <- colnames(dataset %>% dplyr::select(-e0, -country, -year))
  predictors <- paste(predictors, collapse = "+")
  
  mod0 <- plm(e0~Na, data = dataset, index=c("country","year"), model = "within")
  fe0 <- coeftest(mod0, vcov = vcovHC(mod0, type = "HC1"))

  mod1 <- plm(e0~Na+etoh, data = dataset, index=c("country","year"), model = "within")
  fe1 <- coeftest(mod1, vcov = vcovHC(mod1, type = "HC1"))

  mod2 <- plm(e0~Na+etoh+smoking, data = dataset, index=c("country","year"), model = "within")
  fe2 <- coeftest(mod2, vcov = vcovHC(mod2, type = "HC1"))
  
  mod <- lm(e0~Na+etoh+smoking+pc_gdp, data = dataset)
  OLS <- coeftest(mod)
  robust <- coeftest(mod, vcov = vcovHC(mod, type = "HC1"))
  mod <- plm(e0~Na+etoh+smoking+pc_gdp, data = dataset, index=c("country","year"), model = "within")
  fe <- coeftest(mod, vcov = vcovHC(mod, type = "HC1"))
  return(list(
    "plain" = fe0,
    "etoh"  = fe1,
    "etoh smoke" = fe2,
    "OLS" = OLS,
    "robust" = robust,
    "fixed effects" = fe
  ))
}
```
First, we look at conventional linear models for the differenced data. We report usual OLS standard errors as well as Huber-White robust standard errors.
If salt were detrimental, then we'd expect to see a negative coefficient in the linear model.
We do observe a negative coefficient for males, when we don't include any other variables in the model.
However, as soon as we add alcohol to the model, the association disappears because increases in alcohol consumption explain a large portion of the decrease in life expectancy.
We consider the full model including alcohol, smoking, and per capita GDP, in columns (7) and (8).
For males, a one unit increase in sodium consumption from 1990 to 2010 is associated with an increase in life expectancy of $0.271$ years.
For females, it's associated with a $2.073$ year increase in life expectancy between 1990 and 2010 (significant at 10\% level).


```{r do_linear_models, results="asis", echo=FALSE, cache=TRUE}
compute_linear_models_differenced(male_diff) %>% stargazer(type = "html", 
                                                           style = "qje",
                                                           title = "Male, Differenced",
                                                           column.labels = rep(c("OLS", "Robust"), 4),
                                                           notes = "")
compute_linear_models_differenced(female_diff) %>% stargazer(type = "html", 
                                                           style = "qje",
                                                           title = "Female, Differenced",
                                                           column.labels = c("OLS", "Robust"),
                                                           notes = "")
```

Next, we look at the data cross-sectionally instead of taking the difference over time.
Again, if salt were detrimental to health, we'd expect it to have a negative coefficient in the linear model.
We find the opposite: in all fixed effect specifications that we run, salt has a significant positive effect on life expectancy at age 30.
In the OLS models, salt has no significant assoiation with life expectancy.
In the full fixed effects model, for males, a one unit increase in sodium consumption is associated with an increase in life expectancy of $3.004$ years (significant at 10\% level).
For females, it's associated with a $6.06$ year increase in life expectancy (significant at 1\% level).

```{r do_fixed_effects, results="asis", echo=FALSE, cache=TRUE}
compute_fixed_effects(male_absolute) %>% stargazer(type = "html", 
                                                           style = "qje",
                                                           title = "Male, Absolute",
                                                           column.labels = c("Fixed Effects","Fixed Effects","Fixed Effects","OLS", "Robust", "Fixed Effects"),
                                                           notes = "")
compute_fixed_effects(female_absolute) %>% stargazer(type = "html", 
                                                           style = "qje",
                                                           title = "Female, Absolute",
                                                           column.labels = c("Fixed Effects","Fixed Effects","Fixed Effects","OLS", "Robust", "Fixed Effects"),
                                                           notes = "")
```

### R and package versions used
```{r sessionInfo, include=TRUE, echo=TRUE, results='markup'}
sessionInfo()
```

